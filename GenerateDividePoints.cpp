//
// Generator Divide Target Points
void VanitySearch::GenerateCodeDP(Secp256K1 *secp, int size) {
	
	// Compute Generator Divide Target Points
	size = 256;
	
	Point T_Point;
	
	T_Point = targetPubKey;// Target PubKey
	
	Int *Dk = new Int[size];
	Point *Dp = new Point[size];
	
	Dk[0].SetInt32(1);
	Dp[0] = T_Point;
	
	Int DivideKey;
	DivideKey.SetInt32(1);
	Int _One;
	_One.SetInt32(1);
	
	for (int i = 1; i < size; i++) {
		printf("\nGenerate Divide Target Points GPUDividePoints.h size i: %d", i);
		//
		DivideKey.Add(&DivideKey, &_One);// + 1
		Dk[i].Set(&DivideKey);
		printf("\n   DivKey: %s", Dk[i].GetBase16().c_str());
		Dk[i].ModInvOrder();// !!! OK Inverse modulo _N the Divide key
		Dp[i] = secp->MultKAffine(Dk[i], T_Point);// divide Point
		//
		printf("\nInvDivKey: %s", Dk[i].GetBase16().c_str());
	}
	
	// Write file
	FILE *f = fopen("GPU/GPUDividePoints.h", "wb");
	fprintf(f, "// File generated by GenerateCodeDP()\n");
	fprintf(f, "\n\n");
	fprintf(f, "// SecpK1 Generator Divide Target Points P/1, P/2, P/3, P/4, P/5,..., P/255. \n", size);
	fprintf(f, "__device__ __constant__ uint64_t Dpx[][4] = {\n");
	for (int i = 0; i < size; i++) {
		fprintf(f, "    %s,\n", Dp[i].x.GetC64Str(4).c_str());
	}
	fprintf(f, "};\n");
	
	fprintf(f, "__device__ __constant__ uint64_t Dpy[][4] = {\n");
	for (int i = 0; i < size; i++) {
		fprintf(f, "    %s,\n", Dp[i].y.GetC64Str(4).c_str());
	}
	fprintf(f, "};\n\n");
	
	fprintf(f, "__device__ __constant__ uint64_t Dk[][4] = {\n");
	for (int i = 0; i < size; i++) {
		fprintf(f, "    %s,\n", Dk[i].GetC64Str(4).c_str());
	}
	fprintf(f, "};\n\n");
	
	fclose(f);
	delete[] Dk;
	delete[] Dp;

}

